/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
/* eslint-disable @angular-eslint/component-selector */
import { ChangeDetectionStrategy, Component, EventEmitter, Input, NgZone, Output, ViewChildren, ViewEncapsulation } from '@angular/core';
import { Subject, combineLatest } from 'rxjs';
import { debounceTime, map, startWith, switchMap, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/cdk/resize-observer";
import * as i2 from "@angular/common";
class NzTrMeasureComponent {
    constructor(nzResizeObserver, ngZone) {
        this.nzResizeObserver = nzResizeObserver;
        this.ngZone = ngZone;
        this.listOfMeasureColumn = [];
        this.listOfAutoWidth = new EventEmitter();
        this.destroy$ = new Subject();
    }
    trackByFunc(_, key) {
        return key;
    }
    ngAfterViewInit() {
        this.listOfTdElement.changes
            .pipe(startWith(this.listOfTdElement))
            .pipe(switchMap(list => combineLatest(list.toArray().map((item) => this.nzResizeObserver.observe(item).pipe(map(([entry]) => {
            const { width } = entry.target.getBoundingClientRect();
            return Math.floor(width);
        }))))), debounceTime(16), takeUntil(this.destroy$))
            .subscribe(data => {
            // Caretaker note: we don't have to re-enter the Angular zone each time the stream emits.
            // The below check is necessary to be sure that zone is not nooped through `BootstrapOptions`
            // (`bootstrapModule(AppModule, { ngZone: 'noop' }))`. The `ngZone instanceof NgZone` may return
            // `false` if zone is nooped, since `ngZone` will be an instance of the `NoopNgZone`.
            // The `ResizeObserver` might be also patched through `zone.js/dist/zone-patch-resize-observer`,
            // thus calling `ngZone.run` again will cause another change detection.
            if (this.ngZone instanceof NgZone && NgZone.isInAngularZone()) {
                this.listOfAutoWidth.next(data);
            }
            else {
                this.ngZone.run(() => this.listOfAutoWidth.next(data));
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTrMeasureComponent, deps: [{ token: i1.NzResizeObserver }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.10", type: NzTrMeasureComponent, selector: "tr[nz-table-measure-row]", inputs: { listOfMeasureColumn: "listOfMeasureColumn" }, outputs: { listOfAutoWidth: "listOfAutoWidth" }, host: { classAttribute: "ant-table-measure-now" }, viewQueries: [{ propertyName: "listOfTdElement", predicate: ["tdElement"], descendants: true }], ngImport: i0, template: `
    <td
      #tdElement
      class="nz-disable-td"
      style="padding: 0px; border: 0px; height: 0px;"
      *ngFor="let th of listOfMeasureColumn; trackBy: trackByFunc"
    ></td>
  `, isInline: true, dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
export { NzTrMeasureComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTrMeasureComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tr[nz-table-measure-row]',
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    template: `
    <td
      #tdElement
      class="nz-disable-td"
      style="padding: 0px; border: 0px; height: 0px;"
      *ngFor="let th of listOfMeasureColumn; trackBy: trackByFunc"
    ></td>
  `,
                    host: { class: 'ant-table-measure-now' }
                }]
        }], ctorParameters: function () { return [{ type: i1.NzResizeObserver }, { type: i0.NgZone }]; }, propDecorators: { listOfMeasureColumn: [{
                type: Input
            }], listOfAutoWidth: [{
                type: Output
            }], listOfTdElement: [{
                type: ViewChildren,
                args: ['tdElement']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHItbWVhc3VyZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9jb21wb25lbnRzL3RhYmxlL3NyYy90YWJsZS90ci1tZWFzdXJlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFFSCx1REFBdUQ7QUFFdkQsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixTQUFTLEVBRVQsWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBRU4sTUFBTSxFQUVOLFlBQVksRUFDWixpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFjLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDMUQsT0FBTyxFQUFFLFlBQVksRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUlwRixNQWVhLG9CQUFvQjtJQUsvQixZQUFvQixnQkFBa0MsRUFBVSxNQUFjO1FBQTFELHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBSnJFLHdCQUFtQixHQUFzQixFQUFFLENBQUM7UUFDbEMsb0JBQWUsR0FBRyxJQUFJLFlBQVksRUFBWSxDQUFDO1FBRTFELGFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO0lBQ3VDLENBQUM7SUFDbEYsV0FBVyxDQUFDLENBQVMsRUFBRSxHQUFXO1FBQ2hDLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUNELGVBQWU7UUFDYixJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU87YUFDekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7YUFDckMsSUFBSSxDQUNILFNBQVMsQ0FDUCxJQUFJLENBQUMsRUFBRSxDQUNMLGFBQWEsQ0FDWCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBZ0IsRUFBRSxFQUFFLENBQ3RDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUN0QyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDZCxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1lBQ3ZELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FDSCxDQUNGLENBQ3NCLENBQzVCLEVBQ0QsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUNoQixTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUN6QjthQUNBLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNoQix5RkFBeUY7WUFDekYsNkZBQTZGO1lBQzdGLGdHQUFnRztZQUNoRyxxRkFBcUY7WUFDckYsZ0dBQWdHO1lBQ2hHLHVFQUF1RTtZQUN2RSxJQUFJLElBQUksQ0FBQyxNQUFNLFlBQVksTUFBTSxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsRUFBRTtnQkFDN0QsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDakM7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUN4RDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUNELFdBQVc7UUFDVCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzNCLENBQUM7K0dBOUNVLG9CQUFvQjttR0FBcEIsb0JBQW9CLDZUQVZyQjs7Ozs7OztHQU9UOztTQUdVLG9CQUFvQjs0RkFBcEIsb0JBQW9CO2tCQWZoQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSwwQkFBMEI7b0JBQ3BDLG1CQUFtQixFQUFFLEtBQUs7b0JBQzFCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtvQkFDckMsUUFBUSxFQUFFOzs7Ozs7O0dBT1Q7b0JBQ0QsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLHVCQUF1QixFQUFFO2lCQUN6Qzs0SEFFVSxtQkFBbUI7c0JBQTNCLEtBQUs7Z0JBQ2EsZUFBZTtzQkFBakMsTUFBTTtnQkFDb0IsZUFBZTtzQkFBekMsWUFBWTt1QkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgQGFuZ3VsYXItZXNsaW50L2NvbXBvbmVudC1zZWxlY3RvciAqL1xuXG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFZpZXdDaGlsZHJlbixcbiAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBjb21iaW5lTGF0ZXN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIG1hcCwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnpSZXNpemVPYnNlcnZlciB9IGZyb20gJ25nLXpvcnJvLWFudGQvY2RrL3Jlc2l6ZS1vYnNlcnZlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3RyW256LXRhYmxlLW1lYXN1cmUtcm93XScsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgdGVtcGxhdGU6IGBcbiAgICA8dGRcbiAgICAgICN0ZEVsZW1lbnRcbiAgICAgIGNsYXNzPVwibnotZGlzYWJsZS10ZFwiXG4gICAgICBzdHlsZT1cInBhZGRpbmc6IDBweDsgYm9yZGVyOiAwcHg7IGhlaWdodDogMHB4O1wiXG4gICAgICAqbmdGb3I9XCJsZXQgdGggb2YgbGlzdE9mTWVhc3VyZUNvbHVtbjsgdHJhY2tCeTogdHJhY2tCeUZ1bmNcIlxuICAgID48L3RkPlxuICBgLFxuICBob3N0OiB7IGNsYXNzOiAnYW50LXRhYmxlLW1lYXN1cmUtbm93JyB9XG59KVxuZXhwb3J0IGNsYXNzIE56VHJNZWFzdXJlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgQElucHV0KCkgbGlzdE9mTWVhc3VyZUNvbHVtbjogcmVhZG9ubHkgc3RyaW5nW10gPSBbXTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IGxpc3RPZkF1dG9XaWR0aCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyW10+KCk7XG4gIEBWaWV3Q2hpbGRyZW4oJ3RkRWxlbWVudCcpIGxpc3RPZlRkRWxlbWVudCE6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcbiAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbnpSZXNpemVPYnNlcnZlcjogTnpSZXNpemVPYnNlcnZlciwgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge31cbiAgdHJhY2tCeUZ1bmMoXzogbnVtYmVyLCBrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy5saXN0T2ZUZEVsZW1lbnQuY2hhbmdlc1xuICAgICAgLnBpcGUoc3RhcnRXaXRoKHRoaXMubGlzdE9mVGRFbGVtZW50KSlcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoXG4gICAgICAgICAgbGlzdCA9PlxuICAgICAgICAgICAgY29tYmluZUxhdGVzdChcbiAgICAgICAgICAgICAgbGlzdC50b0FycmF5KCkubWFwKChpdGVtOiBFbGVtZW50UmVmKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMubnpSZXNpemVPYnNlcnZlci5vYnNlcnZlKGl0ZW0pLnBpcGUoXG4gICAgICAgICAgICAgICAgICBtYXAoKFtlbnRyeV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gZW50cnkudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih3aWR0aCk7XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSBhcyBPYnNlcnZhYmxlPG51bWJlcltdPlxuICAgICAgICApLFxuICAgICAgICBkZWJvdW5jZVRpbWUoMTYpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoZGF0YSA9PiB7XG4gICAgICAgIC8vIENhcmV0YWtlciBub3RlOiB3ZSBkb24ndCBoYXZlIHRvIHJlLWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgZWFjaCB0aW1lIHRoZSBzdHJlYW0gZW1pdHMuXG4gICAgICAgIC8vIFRoZSBiZWxvdyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gYmUgc3VyZSB0aGF0IHpvbmUgaXMgbm90IG5vb3BlZCB0aHJvdWdoIGBCb290c3RyYXBPcHRpb25zYFxuICAgICAgICAvLyAoYGJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUsIHsgbmdab25lOiAnbm9vcCcgfSkpYC4gVGhlIGBuZ1pvbmUgaW5zdGFuY2VvZiBOZ1pvbmVgIG1heSByZXR1cm5cbiAgICAgICAgLy8gYGZhbHNlYCBpZiB6b25lIGlzIG5vb3BlZCwgc2luY2UgYG5nWm9uZWAgd2lsbCBiZSBhbiBpbnN0YW5jZSBvZiB0aGUgYE5vb3BOZ1pvbmVgLlxuICAgICAgICAvLyBUaGUgYFJlc2l6ZU9ic2VydmVyYCBtaWdodCBiZSBhbHNvIHBhdGNoZWQgdGhyb3VnaCBgem9uZS5qcy9kaXN0L3pvbmUtcGF0Y2gtcmVzaXplLW9ic2VydmVyYCxcbiAgICAgICAgLy8gdGh1cyBjYWxsaW5nIGBuZ1pvbmUucnVuYCBhZ2FpbiB3aWxsIGNhdXNlIGFub3RoZXIgY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMubmdab25lIGluc3RhbmNlb2YgTmdab25lICYmIE5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgIHRoaXMubGlzdE9mQXV0b1dpZHRoLm5leHQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMubGlzdE9mQXV0b1dpZHRoLm5leHQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICB9XG59XG4iXX0=