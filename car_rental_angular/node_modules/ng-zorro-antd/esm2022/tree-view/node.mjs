/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { CdkTreeNode, CdkTreeNodeDef } from '@angular/cdk/tree';
import { ChangeDetectionStrategy, Component, Directive, Input } from '@angular/core';
import { NzNodeBase } from './node-base';
import * as i0 from "@angular/core";
import * as i1 from "./tree";
import * as i2 from "@angular/common";
import * as i3 from "./toggle";
import * as i4 from "./indent";
class NzTreeNodeComponent extends NzNodeBase {
    constructor(elementRef, tree, renderer, cdr) {
        super(elementRef, tree);
        this.elementRef = elementRef;
        this.tree = tree;
        this.renderer = renderer;
        this.cdr = cdr;
        this.indents = [];
        this.disabled = false;
        this.selected = false;
        this.isLeaf = false;
        this._elementRef.nativeElement.classList.add('ant-tree-treenode');
    }
    ngOnInit() {
        this.isLeaf = !this.tree.treeControl.isExpandable(this.data);
    }
    disable() {
        this.disabled = true;
        this.updateDisabledClass();
    }
    enable() {
        this.disabled = false;
        this.updateDisabledClass();
    }
    select() {
        this.selected = true;
        this.updateSelectedClass();
    }
    deselect() {
        this.selected = false;
        this.updateSelectedClass();
    }
    setIndents(indents) {
        this.indents = indents;
        this.cdr.markForCheck();
    }
    updateSelectedClass() {
        if (this.selected) {
            this.renderer.addClass(this.elementRef.nativeElement, 'ant-tree-treenode-selected');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'ant-tree-treenode-selected');
        }
    }
    updateDisabledClass() {
        if (this.disabled) {
            this.renderer.addClass(this.elementRef.nativeElement, 'ant-tree-treenode-disabled');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'ant-tree-treenode-disabled');
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeNodeComponent, deps: [{ token: i0.ElementRef }, { token: i1.NzTreeView }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.10", type: NzTreeNodeComponent, selector: "nz-tree-node:not([builtin])", host: { properties: { "class.ant-tree-treenode-switcher-open": "isExpanded", "class.ant-tree-treenode-switcher-close": "!isExpanded" } }, providers: [
            { provide: CdkTreeNode, useExisting: NzTreeNodeComponent },
            { provide: NzNodeBase, useExisting: NzTreeNodeComponent }
        ], exportAs: ["nzTreeNode"], usesInheritance: true, ngImport: i0, template: `
    <nz-tree-node-indents [indents]="indents" *ngIf="indents.length"></nz-tree-node-indents>
    <ng-content select="nz-tree-node-toggle, [nz-tree-node-toggle]"></ng-content>
    <nz-tree-node-toggle class="nz-tree-leaf-line-icon" *ngIf="indents.length && isLeaf" nzTreeNodeNoopToggle>
      <span class="ant-tree-switcher-leaf-line"></span>
    </nz-tree-node-toggle>
    <ng-content select="nz-tree-node-checkbox"></ng-content>
    <ng-content select="nz-tree-node-option"></ng-content>
    <ng-content></ng-content>
  `, isInline: true, dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NzTreeNodeNoopToggleDirective, selector: "nz-tree-node-toggle[nzTreeNodeNoopToggle], [nzTreeNodeNoopToggle]" }, { kind: "component", type: i4.NzTreeNodeIndentsComponent, selector: "nz-tree-node-indents", inputs: ["indents"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { NzTreeNodeComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeNodeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-node:not([builtin])',
                    exportAs: 'nzTreeNode',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: CdkTreeNode, useExisting: NzTreeNodeComponent },
                        { provide: NzNodeBase, useExisting: NzTreeNodeComponent }
                    ],
                    template: `
    <nz-tree-node-indents [indents]="indents" *ngIf="indents.length"></nz-tree-node-indents>
    <ng-content select="nz-tree-node-toggle, [nz-tree-node-toggle]"></ng-content>
    <nz-tree-node-toggle class="nz-tree-leaf-line-icon" *ngIf="indents.length && isLeaf" nzTreeNodeNoopToggle>
      <span class="ant-tree-switcher-leaf-line"></span>
    </nz-tree-node-toggle>
    <ng-content select="nz-tree-node-checkbox"></ng-content>
    <ng-content select="nz-tree-node-option"></ng-content>
    <ng-content></ng-content>
  `,
                    host: {
                        '[class.ant-tree-treenode-switcher-open]': 'isExpanded',
                        '[class.ant-tree-treenode-switcher-close]': '!isExpanded'
                    }
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.NzTreeView }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; } });
class NzTreeNodeDefDirective extends CdkTreeNodeDef {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeNodeDefDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.10", type: NzTreeNodeDefDirective, selector: "[nzTreeNodeDef]", inputs: { when: ["nzTreeNodeDefWhen", "when"] }, providers: [{ provide: CdkTreeNodeDef, useExisting: NzTreeNodeDefDirective }], usesInheritance: true, ngImport: i0 }); }
}
export { NzTreeNodeDefDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeNodeDefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nzTreeNodeDef]',
                    providers: [{ provide: CdkTreeNodeDef, useExisting: NzTreeNodeDefDirective }]
                }]
        }], propDecorators: { when: [{
                type: Input,
                args: ['nzTreeNodeDefWhen']
            }] } });
class NzTreeVirtualScrollNodeOutletDirective {
    constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
        this._viewRef = null;
    }
    ngOnChanges(changes) {
        const recreateView = this.shouldRecreateView(changes);
        if (recreateView) {
            const viewContainerRef = this._viewContainerRef;
            if (this._viewRef) {
                viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = this.data
                ? viewContainerRef.createEmbeddedView(this.data.nodeDef.template, this.data.context)
                : null;
            if (CdkTreeNode.mostRecentTreeNode && this._viewRef) {
                CdkTreeNode.mostRecentTreeNode.data = this.data.data;
            }
        }
        else if (this._viewRef && this.data.context) {
            this.updateExistingContext(this.data.context);
        }
    }
    shouldRecreateView(changes) {
        const ctxChange = changes.data;
        return ctxChange && this.hasContextShapeChanged(ctxChange);
    }
    hasContextShapeChanged(ctxChange) {
        const prevCtxKeys = Object.keys(ctxChange.previousValue || {});
        const currCtxKeys = Object.keys(ctxChange.currentValue || {});
        if (prevCtxKeys.length === currCtxKeys.length) {
            for (const propName of currCtxKeys) {
                if (prevCtxKeys.indexOf(propName) === -1) {
                    return true;
                }
            }
            return (this.innerCompareBy(ctxChange.previousValue?.data ?? null) !==
                this.innerCompareBy(ctxChange.currentValue?.data ?? null));
        }
        return true;
    }
    get innerCompareBy() {
        return value => {
            if (value === null)
                return value;
            if (this.compareBy)
                return this.compareBy(value);
            return value;
        };
    }
    updateExistingContext(ctx) {
        for (const propName of Object.keys(ctx)) {
            this._viewRef.context[propName] = this.data.context[propName];
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeVirtualScrollNodeOutletDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.10", type: NzTreeVirtualScrollNodeOutletDirective, selector: "[nzTreeVirtualScrollNodeOutlet]", inputs: { data: "data", compareBy: "compareBy" }, usesOnChanges: true, ngImport: i0 }); }
}
export { NzTreeVirtualScrollNodeOutletDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeVirtualScrollNodeOutletDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nzTreeVirtualScrollNodeOutlet]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { data: [{
                type: Input
            }], compareBy: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2NvbXBvbmVudHMvdHJlZS12aWV3L25vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHO0FBRUgsT0FBTyxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQTRCLE1BQU0sbUJBQW1CLENBQUM7QUFDMUYsT0FBTyxFQUNMLHVCQUF1QixFQUV2QixTQUFTLEVBQ1QsU0FBUyxFQUdULEtBQUssRUFRTixNQUFNLGVBQWUsQ0FBQztBQUl2QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFBYSxDQUFDOzs7Ozs7QUFTekMsTUF1QmEsbUJBQXVCLFNBQVEsVUFBYTtJQU12RCxZQUNZLFVBQW1DLEVBQ25DLElBQW1CLEVBQ3JCLFFBQW1CLEVBQ25CLEdBQXNCO1FBRTlCLEtBQUssQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFMZCxlQUFVLEdBQVYsVUFBVSxDQUF5QjtRQUNuQyxTQUFJLEdBQUosSUFBSSxDQUFlO1FBQ3JCLGFBQVEsR0FBUixRQUFRLENBQVc7UUFDbkIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFUaEMsWUFBTyxHQUFjLEVBQUUsQ0FBQztRQUN4QixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsV0FBTSxHQUFHLEtBQUssQ0FBQztRQVNiLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRVEsUUFBUTtRQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFRCxPQUFPO1FBQ0wsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDLG1C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Q0FBc0M7bUdBQXRDLHNDQUFzQzs7U0FBdEMsc0NBQXNDOzRGQUF0QyxzQ0FBc0M7a0JBSGxELFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGlDQUFpQztpQkFDNUM7dUdBR1UsSUFBSTtzQkFBWixLQUFLO2dCQUNHLFNBQVM7c0JBQWpCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQgeyBDZGtUcmVlTm9kZSwgQ2RrVHJlZU5vZGVEZWYsIENka1RyZWVOb2RlT3V0bGV0Q29udGV4dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90cmVlJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFJlbmRlcmVyMixcbiAgU2ltcGxlQ2hhbmdlLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBOelNhZmVBbnkgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdHlwZXMnO1xuXG5pbXBvcnQgeyBOek5vZGVCYXNlIH0gZnJvbSAnLi9ub2RlLWJhc2UnO1xuaW1wb3J0IHsgTnpUcmVlVmlldyB9IGZyb20gJy4vdHJlZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTnpUcmVlVmlydHVhbE5vZGVEYXRhPFQ+IHtcbiAgZGF0YTogVDtcbiAgY29udGV4dDogQ2RrVHJlZU5vZGVPdXRsZXRDb250ZXh0PFQ+O1xuICBub2RlRGVmOiBDZGtUcmVlTm9kZURlZjxUPjtcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbnotdHJlZS1ub2RlOm5vdChbYnVpbHRpbl0pJyxcbiAgZXhwb3J0QXM6ICduelRyZWVOb2RlJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByb3ZpZGVyczogW1xuICAgIHsgcHJvdmlkZTogQ2RrVHJlZU5vZGUsIHVzZUV4aXN0aW5nOiBOelRyZWVOb2RlQ29tcG9uZW50IH0sXG4gICAgeyBwcm92aWRlOiBOek5vZGVCYXNlLCB1c2VFeGlzdGluZzogTnpUcmVlTm9kZUNvbXBvbmVudCB9XG4gIF0sXG4gIHRlbXBsYXRlOiBgXG4gICAgPG56LXRyZWUtbm9kZS1pbmRlbnRzIFtpbmRlbnRzXT1cImluZGVudHNcIiAqbmdJZj1cImluZGVudHMubGVuZ3RoXCI+PC9uei10cmVlLW5vZGUtaW5kZW50cz5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuei10cmVlLW5vZGUtdG9nZ2xlLCBbbnotdHJlZS1ub2RlLXRvZ2dsZV1cIj48L25nLWNvbnRlbnQ+XG4gICAgPG56LXRyZWUtbm9kZS10b2dnbGUgY2xhc3M9XCJuei10cmVlLWxlYWYtbGluZS1pY29uXCIgKm5nSWY9XCJpbmRlbnRzLmxlbmd0aCAmJiBpc0xlYWZcIiBuelRyZWVOb2RlTm9vcFRvZ2dsZT5cbiAgICAgIDxzcGFuIGNsYXNzPVwiYW50LXRyZWUtc3dpdGNoZXItbGVhZi1saW5lXCI+PC9zcGFuPlxuICAgIDwvbnotdHJlZS1ub2RlLXRvZ2dsZT5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuei10cmVlLW5vZGUtY2hlY2tib3hcIj48L25nLWNvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibnotdHJlZS1ub2RlLW9wdGlvblwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmFudC10cmVlLXRyZWVub2RlLXN3aXRjaGVyLW9wZW5dJzogJ2lzRXhwYW5kZWQnLFxuICAgICdbY2xhc3MuYW50LXRyZWUtdHJlZW5vZGUtc3dpdGNoZXItY2xvc2VdJzogJyFpc0V4cGFuZGVkJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE56VHJlZU5vZGVDb21wb25lbnQ8VD4gZXh0ZW5kcyBOek5vZGVCYXNlPFQ+IGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQge1xuICBpbmRlbnRzOiBib29sZWFuW10gPSBbXTtcbiAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgaXNMZWFmID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIHByb3RlY3RlZCB0cmVlOiBOelRyZWVWaWV3PFQ+LFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgKSB7XG4gICAgc3VwZXIoZWxlbWVudFJlZiwgdHJlZSk7XG4gICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FudC10cmVlLXRyZWVub2RlJyk7XG4gIH1cblxuICBvdmVycmlkZSBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmlzTGVhZiA9ICF0aGlzLnRyZWUudHJlZUNvbnRyb2wuaXNFeHBhbmRhYmxlKHRoaXMuZGF0YSk7XG4gIH1cblxuICBkaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlRGlzYWJsZWRDbGFzcygpO1xuICB9XG5cbiAgZW5hYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZURpc2FibGVkQ2xhc3MoKTtcbiAgfVxuXG4gIHNlbGVjdCgpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkQ2xhc3MoKTtcbiAgfVxuXG4gIGRlc2VsZWN0KCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkQ2xhc3MoKTtcbiAgfVxuXG4gIHNldEluZGVudHMoaW5kZW50czogYm9vbGVhbltdKTogdm9pZCB7XG4gICAgdGhpcy5pbmRlbnRzID0gaW5kZW50cztcbiAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU2VsZWN0ZWRDbGFzcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2FudC10cmVlLXRyZWVub2RlLXNlbGVjdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhbnQtdHJlZS10cmVlbm9kZS1zZWxlY3RlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGlzYWJsZWRDbGFzcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2FudC10cmVlLXRyZWVub2RlLWRpc2FibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhbnQtdHJlZS10cmVlbm9kZS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbnpUcmVlTm9kZURlZl0nLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka1RyZWVOb2RlRGVmLCB1c2VFeGlzdGluZzogTnpUcmVlTm9kZURlZkRpcmVjdGl2ZSB9XVxufSlcbmV4cG9ydCBjbGFzcyBOelRyZWVOb2RlRGVmRGlyZWN0aXZlPFQ+IGV4dGVuZHMgQ2RrVHJlZU5vZGVEZWY8VD4ge1xuICBASW5wdXQoJ256VHJlZU5vZGVEZWZXaGVuJykgb3ZlcnJpZGUgd2hlbiE6IChpbmRleDogbnVtYmVyLCBub2RlRGF0YTogVCkgPT4gYm9vbGVhbjtcbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW256VHJlZVZpcnR1YWxTY3JvbGxOb2RlT3V0bGV0XSdcbn0pXG5leHBvcnQgY2xhc3MgTnpUcmVlVmlydHVhbFNjcm9sbE5vZGVPdXRsZXREaXJlY3RpdmU8VD4gaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBwcml2YXRlIF92aWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8TnpTYWZlQW55PiB8IG51bGwgPSBudWxsO1xuICBASW5wdXQoKSBkYXRhITogTnpUcmVlVmlydHVhbE5vZGVEYXRhPFQ+O1xuICBASW5wdXQoKSBjb21wYXJlQnk/OiAoKHZhbHVlOiBUKSA9PiBUIHwgc3RyaW5nIHwgbnVtYmVyKSB8IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgY29uc3QgcmVjcmVhdGVWaWV3ID0gdGhpcy5zaG91bGRSZWNyZWF0ZVZpZXcoY2hhbmdlcyk7XG4gICAgaWYgKHJlY3JlYXRlVmlldykge1xuICAgICAgY29uc3Qgdmlld0NvbnRhaW5lclJlZiA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWY7XG5cbiAgICAgIGlmICh0aGlzLl92aWV3UmVmKSB7XG4gICAgICAgIHZpZXdDb250YWluZXJSZWYucmVtb3ZlKHZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ZpZXdSZWYgPSB0aGlzLmRhdGFcbiAgICAgICAgPyB2aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLmRhdGEubm9kZURlZi50ZW1wbGF0ZSwgdGhpcy5kYXRhLmNvbnRleHQpXG4gICAgICAgIDogbnVsbDtcblxuICAgICAgaWYgKENka1RyZWVOb2RlLm1vc3RSZWNlbnRUcmVlTm9kZSAmJiB0aGlzLl92aWV3UmVmKSB7XG4gICAgICAgIENka1RyZWVOb2RlLm1vc3RSZWNlbnRUcmVlTm9kZS5kYXRhID0gdGhpcy5kYXRhLmRhdGE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl92aWV3UmVmICYmIHRoaXMuZGF0YS5jb250ZXh0KSB7XG4gICAgICB0aGlzLnVwZGF0ZUV4aXN0aW5nQ29udGV4dCh0aGlzLmRhdGEuY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRSZWNyZWF0ZVZpZXcoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGN0eENoYW5nZSA9IGNoYW5nZXMuZGF0YTtcbiAgICByZXR1cm4gY3R4Q2hhbmdlICYmIHRoaXMuaGFzQ29udGV4dFNoYXBlQ2hhbmdlZChjdHhDaGFuZ2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYXNDb250ZXh0U2hhcGVDaGFuZ2VkKGN0eENoYW5nZTogU2ltcGxlQ2hhbmdlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHJldkN0eEtleXMgPSBPYmplY3Qua2V5cyhjdHhDaGFuZ2UucHJldmlvdXNWYWx1ZSB8fCB7fSk7XG4gICAgY29uc3QgY3VyckN0eEtleXMgPSBPYmplY3Qua2V5cyhjdHhDaGFuZ2UuY3VycmVudFZhbHVlIHx8IHt9KTtcblxuICAgIGlmIChwcmV2Q3R4S2V5cy5sZW5ndGggPT09IGN1cnJDdHhLZXlzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBjdXJyQ3R4S2V5cykge1xuICAgICAgICBpZiAocHJldkN0eEtleXMuaW5kZXhPZihwcm9wTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuaW5uZXJDb21wYXJlQnkoY3R4Q2hhbmdlLnByZXZpb3VzVmFsdWU/LmRhdGEgPz8gbnVsbCkgIT09XG4gICAgICAgIHRoaXMuaW5uZXJDb21wYXJlQnkoY3R4Q2hhbmdlLmN1cnJlbnRWYWx1ZT8uZGF0YSA/PyBudWxsKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXQgaW5uZXJDb21wYXJlQnkoKTogKHZhbHVlOiBUIHwgbnVsbCkgPT4gVCB8IHN0cmluZyB8IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLmNvbXBhcmVCeSkgcmV0dXJuIHRoaXMuY29tcGFyZUJ5KHZhbHVlIGFzIFQpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUV4aXN0aW5nQ29udGV4dChjdHg6IE56U2FmZUFueSk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgb2YgT2JqZWN0LmtleXMoY3R4KSkge1xuICAgICAgdGhpcy5fdmlld1JlZiEuY29udGV4dFtwcm9wTmFtZV0gPSAodGhpcy5kYXRhLmNvbnRleHQgYXMgTnpTYWZlQW55KVtwcm9wTmFtZV07XG4gICAgfVxuICB9XG59XG4iXX0=