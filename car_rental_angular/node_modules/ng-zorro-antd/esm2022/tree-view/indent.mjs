/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, Directive, Input } from '@angular/core';
import { animationFrameScheduler, asapScheduler, merge } from 'rxjs';
import { auditTime } from 'rxjs/operators';
import { getNextSibling, getParent } from './utils';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./node-base";
import * as i3 from "./tree";
/**
 * [true, false, false, true] => 1001
 */
function booleanArrayToString(arr) {
    return arr.map(i => (i ? 1 : 0)).join('');
}
const BUILD_INDENTS_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;
class NzTreeNodeIndentsComponent {
    constructor() {
        this.indents = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeNodeIndentsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.10", type: NzTreeNodeIndentsComponent, selector: "nz-tree-node-indents", inputs: { indents: "indents" }, host: { classAttribute: "ant-tree-indent" }, ngImport: i0, template: `
    <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd" *ngFor="let isEnd of indents"></span>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { NzTreeNodeIndentsComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeNodeIndentsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-node-indents',
                    template: `
    <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd" *ngFor="let isEnd of indents"></span>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        class: 'ant-tree-indent'
                    }
                }]
        }], propDecorators: { indents: [{
                type: Input
            }] } });
class NzTreeNodeIndentLineDirective {
    constructor(treeNode, tree, cdr) {
        this.treeNode = treeNode;
        this.tree = tree;
        this.cdr = cdr;
        this.isLast = 'unset';
        this.isLeaf = false;
        this.preNodeRef = null;
        this.nextNodeRef = null;
        this.currentIndents = '';
        this.buildIndents();
        this.checkLast();
        /**
         * The dependent data (TreeControl.dataNodes) can be set after node instantiation,
         * and setting the indents can cause frame rate loss if it is set too often.
         */
        this.changeSubscription = merge(this.treeNode._dataChanges, tree._dataSourceChanged)
            .pipe(auditTime(0, BUILD_INDENTS_SCHEDULER))
            .subscribe(() => {
            this.buildIndents();
            this.checkAdjacent();
            this.cdr.markForCheck();
        });
    }
    getIndents() {
        const indents = [];
        const nodes = this.tree.treeControl.dataNodes;
        const getLevel = this.tree.treeControl.getLevel;
        let parent = getParent(nodes, this.treeNode.data, getLevel);
        while (parent) {
            const parentNextSibling = getNextSibling(nodes, parent, getLevel);
            if (parentNextSibling) {
                indents.unshift(true);
            }
            else {
                indents.unshift(false);
            }
            parent = getParent(nodes, parent, getLevel);
        }
        return indents;
    }
    buildIndents() {
        if (this.treeNode.data) {
            const indents = this.getIndents();
            const diffString = booleanArrayToString(indents);
            if (diffString !== this.currentIndents) {
                this.treeNode.setIndents(this.getIndents());
                this.currentIndents = diffString;
            }
        }
    }
    /**
     * We need to add an class name for the last child node,
     * this result can also be affected when the adjacent nodes are changed.
     */
    checkAdjacent() {
        const nodes = this.tree.treeControl.dataNodes;
        const index = nodes.indexOf(this.treeNode.data);
        const preNode = nodes[index - 1] || null;
        const nextNode = nodes[index + 1] || null;
        if (this.nextNodeRef !== nextNode || this.preNodeRef !== preNode) {
            this.checkLast(index);
        }
        this.preNodeRef = preNode;
        this.nextNodeRef = nextNode;
    }
    checkLast(index) {
        const nodes = this.tree.treeControl.dataNodes;
        this.isLeaf = this.treeNode.isLeaf;
        this.isLast = !getNextSibling(nodes, this.treeNode.data, this.tree.treeControl.getLevel, index);
    }
    ngOnDestroy() {
        this.preNodeRef = null;
        this.nextNodeRef = null;
        this.changeSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeNodeIndentLineDirective, deps: [{ token: i2.NzNodeBase }, { token: i3.NzTreeView }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.10", type: NzTreeNodeIndentLineDirective, selector: "nz-tree-node[nzTreeNodeIndentLine]", host: { properties: { "class.ant-tree-treenode-leaf-last": "isLast && isLeaf" }, classAttribute: "ant-tree-show-line" }, ngImport: i0 }); }
}
export { NzTreeNodeIndentLineDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTreeNodeIndentLineDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'nz-tree-node[nzTreeNodeIndentLine]',
                    host: {
                        class: 'ant-tree-show-line',
                        '[class.ant-tree-treenode-leaf-last]': 'isLast && isLeaf'
                    }
                }]
        }], ctorParameters: function () { return [{ type: i2.NzNodeBase }, { type: i3.NzTreeView }, { type: i0.ChangeDetectorRef }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vY29tcG9uZW50cy90cmVlLXZpZXcvaW5kZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSx1QkFBdUIsRUFBcUIsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDbkgsT0FBTyxFQUFFLHVCQUF1QixFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQ25GLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUkzQyxPQUFPLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQzs7Ozs7QUFFcEQ7O0dBRUc7QUFDSCxTQUFTLG9CQUFvQixDQUFDLEdBQWM7SUFDMUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQUVELE1BQU0sdUJBQXVCLEdBQUcsT0FBTyxxQkFBcUIsS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7QUFFdkgsTUFVYSwwQkFBMEI7SUFWdkM7UUFXVyxZQUFPLEdBQWMsRUFBRSxDQUFDO0tBQ2xDOytHQUZZLDBCQUEwQjttR0FBMUIsMEJBQTBCLHlJQVIzQjs7R0FFVDs7U0FNVSwwQkFBMEI7NEZBQTFCLDBCQUEwQjtrQkFWdEMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsc0JBQXNCO29CQUNoQyxRQUFRLEVBQUU7O0dBRVQ7b0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLElBQUksRUFBRTt3QkFDSixLQUFL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IGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRGlyZWN0aXZlLCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgYXNhcFNjaGVkdWxlciwgbWVyZ2UsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgYXVkaXRUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOek5vZGVCYXNlIH0gZnJvbSAnLi9ub2RlLWJhc2UnO1xuaW1wb3J0IHsgTnpUcmVlVmlldyB9IGZyb20gJy4vdHJlZSc7XG5pbXBvcnQgeyBnZXROZXh0U2libGluZywgZ2V0UGFyZW50IH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogW3RydWUsIGZhbHNlLCBmYWxzZSwgdHJ1ZV0gPT4gMTAwMVxuICovXG5mdW5jdGlvbiBib29sZWFuQXJyYXlUb1N0cmluZyhhcnI6IGJvb2xlYW5bXSk6IHN0cmluZyB7XG4gIHJldHVybiBhcnIubWFwKGkgPT4gKGkgPyAxIDogMCkpLmpvaW4oJycpO1xufVxuXG5jb25zdCBCVUlMRF9JTkRFTlRTX1NDSEVEVUxFUiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICd1bmRlZmluZWQnID8gYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgOiBhc2FwU2NoZWR1bGVyO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduei10cmVlLW5vZGUtaW5kZW50cycsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHNwYW4gY2xhc3M9XCJhbnQtdHJlZS1pbmRlbnQtdW5pdFwiIFtjbGFzcy5hbnQtdHJlZS1pbmRlbnQtdW5pdC1lbmRdPVwiIWlzRW5kXCIgKm5nRm9yPVwibGV0IGlzRW5kIG9mIGluZGVudHNcIj48L3NwYW4+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICdhbnQtdHJlZS1pbmRlbnQnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnpUcmVlTm9kZUluZGVudHNDb21wb25lbnQge1xuICBASW5wdXQoKSBpbmRlbnRzOiBib29sZWFuW10gPSBbXTtcbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnbnotdHJlZS1ub2RlW256VHJlZU5vZGVJbmRlbnRMaW5lXScsXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ2FudC10cmVlLXNob3ctbGluZScsXG4gICAgJ1tjbGFzcy5hbnQtdHJlZS10cmVlbm9kZS1sZWFmLWxhc3RdJzogJ2lzTGFzdCAmJiBpc0xlYWYnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnpUcmVlTm9kZUluZGVudExpbmVEaXJlY3RpdmU8VD4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBpc0xhc3Q6IGJvb2xlYW4gfCAndW5zZXQnID0gJ3Vuc2V0JztcbiAgaXNMZWFmID0gZmFsc2U7XG4gIHByaXZhdGUgcHJlTm9kZVJlZjogVCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG5leHROb2RlUmVmOiBUIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY3VycmVudEluZGVudHM6IHN0cmluZyA9ICcnO1xuICBwcml2YXRlIGNoYW5nZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdHJlZU5vZGU6IE56Tm9kZUJhc2U8VD4sIHByaXZhdGUgdHJlZTogTnpUcmVlVmlldzxUPiwgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy5idWlsZEluZGVudHMoKTtcbiAgICB0aGlzLmNoZWNrTGFzdCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlcGVuZGVudCBkYXRhIChUcmVlQ29udHJvbC5kYXRhTm9kZXMpIGNhbiBiZSBzZXQgYWZ0ZXIgbm9kZSBpbnN0YW50aWF0aW9uLFxuICAgICAqIGFuZCBzZXR0aW5nIHRoZSBpbmRlbnRzIGNhbiBjYXVzZSBmcmFtZSByYXRlIGxvc3MgaWYgaXQgaXMgc2V0IHRvbyBvZnRlbi5cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZVN1YnNjcmlwdGlvbiA9IG1lcmdlKHRoaXMudHJlZU5vZGUuX2RhdGFDaGFuZ2VzLCB0cmVlLl9kYXRhU291cmNlQ2hhbmdlZClcbiAgICAgIC5waXBlKGF1ZGl0VGltZSgwLCBCVUlMRF9JTkRFTlRTX1NDSEVEVUxFUikpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5idWlsZEluZGVudHMoKTtcbiAgICAgICAgdGhpcy5jaGVja0FkamFjZW50KCk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldEluZGVudHMoKTogYm9vbGVhbltdIHtcbiAgICBjb25zdCBpbmRlbnRzID0gW107XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLnRyZWUudHJlZUNvbnRyb2wuZGF0YU5vZGVzO1xuICAgIGNvbnN0IGdldExldmVsID0gdGhpcy50cmVlLnRyZWVDb250cm9sLmdldExldmVsO1xuICAgIGxldCBwYXJlbnQgPSBnZXRQYXJlbnQobm9kZXMsIHRoaXMudHJlZU5vZGUuZGF0YSwgZ2V0TGV2ZWwpO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGNvbnN0IHBhcmVudE5leHRTaWJsaW5nID0gZ2V0TmV4dFNpYmxpbmcobm9kZXMsIHBhcmVudCwgZ2V0TGV2ZWwpO1xuICAgICAgaWYgKHBhcmVudE5leHRTaWJsaW5nKSB7XG4gICAgICAgIGluZGVudHMudW5zaGlmdCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudHMudW5zaGlmdChmYWxzZSk7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBnZXRQYXJlbnQobm9kZXMsIHBhcmVudCwgZ2V0TGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZW50cztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRJbmRlbnRzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRyZWVOb2RlLmRhdGEpIHtcbiAgICAgIGNvbnN0IGluZGVudHMgPSB0aGlzLmdldEluZGVudHMoKTtcbiAgICAgIGNvbnN0IGRpZmZTdHJpbmcgPSBib29sZWFuQXJyYXlUb1N0cmluZyhpbmRlbnRzKTtcbiAgICAgIGlmIChkaWZmU3RyaW5nICE9PSB0aGlzLmN1cnJlbnRJbmRlbnRzKSB7XG4gICAgICAgIHRoaXMudHJlZU5vZGUuc2V0SW5kZW50cyh0aGlzLmdldEluZGVudHMoKSk7XG4gICAgICAgIHRoaXMuY3VycmVudEluZGVudHMgPSBkaWZmU3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBuZWVkIHRvIGFkZCBhbiBjbGFzcyBuYW1lIGZvciB0aGUgbGFzdCBjaGlsZCBub2RlLFxuICAgKiB0aGlzIHJlc3VsdCBjYW4gYWxzbyBiZSBhZmZlY3RlZCB3aGVuIHRoZSBhZGphY2VudCBub2RlcyBhcmUgY2hhbmdlZC5cbiAgICovXG4gIHByaXZhdGUgY2hlY2tBZGphY2VudCgpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMudHJlZS50cmVlQ29udHJvbC5kYXRhTm9kZXM7XG4gICAgY29uc3QgaW5kZXggPSBub2Rlcy5pbmRleE9mKHRoaXMudHJlZU5vZGUuZGF0YSk7XG4gICAgY29uc3QgcHJlTm9kZSA9IG5vZGVzW2luZGV4IC0gMV0gfHwgbnVsbDtcbiAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVzW2luZGV4ICsgMV0gfHwgbnVsbDtcbiAgICBpZiAodGhpcy5uZXh0Tm9kZVJlZiAhPT0gbmV4dE5vZGUgfHwgdGhpcy5wcmVOb2RlUmVmICE9PSBwcmVOb2RlKSB7XG4gICAgICB0aGlzLmNoZWNrTGFzdChpbmRleCk7XG4gICAgfVxuICAgIHRoaXMucHJlTm9kZVJlZiA9IHByZU5vZGU7XG4gICAgdGhpcy5uZXh0Tm9kZVJlZiA9IG5leHROb2RlO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0xhc3QoaW5kZXg/OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMudHJlZS50cmVlQ29udHJvbC5kYXRhTm9kZXM7XG4gICAgdGhpcy5pc0xlYWYgPSB0aGlzLnRyZWVOb2RlLmlzTGVhZjtcbiAgICB0aGlzLmlzTGFzdCA9ICFnZXROZXh0U2libGluZyhub2RlcywgdGhpcy50cmVlTm9kZS5kYXRhLCB0aGlzLnRyZWUudHJlZUNvbnRyb2wuZ2V0TGV2ZWwsIGluZGV4KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMucHJlTm9kZVJlZiA9IG51bGw7XG4gICAgdGhpcy5uZXh0Tm9kZVJlZiA9IG51bGw7XG4gICAgdGhpcy5jaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19