/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { BehaviorSubject, EMPTY, from, fromEvent, Observable } from 'rxjs';
import { switchMap, take, takeUntil, withLatestFrom } from 'rxjs/operators';
import { NzDestroyService } from 'ng-zorro-antd/core/services';
import { NzAutosizeDirective } from 'ng-zorro-antd/input';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/i18n";
import * as i2 from "ng-zorro-antd/core/services";
import * as i3 from "@angular/common";
import * as i4 from "ng-zorro-antd/icon";
import * as i5 from "ng-zorro-antd/tooltip";
import * as i6 from "ng-zorro-antd/input";
import * as i7 from "ng-zorro-antd/core/trans-button";
import * as i8 from "ng-zorro-antd/core/outlet";
class NzTextEditComponent {
    set textarea(textarea) {
        this.textarea$.next(textarea);
    }
    constructor(ngZone, host, cdr, i18n, destroy$) {
        this.ngZone = ngZone;
        this.host = host;
        this.cdr = cdr;
        this.i18n = i18n;
        this.destroy$ = destroy$;
        this.editing = false;
        this.icon = 'edit';
        this.startEditing = new EventEmitter();
        this.endEditing = new EventEmitter(true);
        this.nativeElement = this.host.nativeElement;
        // We could've saved the textarea within some private property (e.g. `_textarea`) and have a getter,
        // but having subject makes the code more reactive and cancellable (e.g. event listeners will be
        // automatically removed and re-added through the `switchMap` below).
        this.textarea$ = new BehaviorSubject(null);
    }
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.locale = this.i18n.getLocaleData('Text');
            this.cdr.markForCheck();
        });
        this.textarea$
            .pipe(switchMap(textarea => 
        // Caretaker note: we explicitly should call `subscribe()` within the root zone.
        // `runOutsideAngular(() => fromEvent(...))` will just create an observable within the root zone,
        // but `addEventListener` is called when the `fromEvent` is subscribed.
        textarea
            ? new Observable(subscriber => this.ngZone.runOutsideAngular(() => fromEvent(textarea.nativeElement, 'keydown').subscribe(subscriber)))
            : EMPTY), takeUntil(this.destroy$))
            .subscribe(event => {
            // Caretaker note: adding modifier at the end (for instance `(keydown.esc)`) will tell Angular to add
            // an event listener through the `KeyEventsPlugin`, which always runs `ngZone.runGuarded()` internally.
            // We're interested only in escape and enter keyboard buttons, otherwise Angular will run change detection
            // on any `keydown` event.
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                return;
            }
            this.ngZone.run(() => {
                if (event.keyCode === ESCAPE) {
                    this.onCancel();
                }
                else {
                    this.onEnter(event);
                }
                this.cdr.markForCheck();
            });
        });
        this.textarea$
            .pipe(switchMap(textarea => textarea
            ? new Observable(subscriber => this.ngZone.runOutsideAngular(() => fromEvent(textarea.nativeElement, 'input').subscribe(subscriber)))
            : EMPTY), takeUntil(this.destroy$))
            .subscribe(event => {
            this.currentText = event.target.value;
        });
    }
    onClick() {
        this.beforeText = this.text;
        this.currentText = this.beforeText;
        this.editing = true;
        this.startEditing.emit();
        this.focusAndSetValue();
    }
    confirm() {
        this.editing = false;
        this.endEditing.emit(this.currentText);
    }
    onEnter(event) {
        event.stopPropagation();
        event.preventDefault();
        this.confirm();
    }
    onCancel() {
        this.currentText = this.beforeText;
        this.confirm();
    }
    focusAndSetValue() {
        // Note: the zone may be nooped through `BootstrapOptions` when bootstrapping the root module. This means
        // the `onStable` will never emit any value.
        const onStable$ = this.ngZone.isStable ? from(Promise.resolve()) : this.ngZone.onStable.pipe(take(1));
        // Normally this isn't in the zone, but it can cause performance regressions for apps
        // using `zone-patch-rxjs` because it'll trigger a change detection when it unsubscribes.
        this.ngZone.runOutsideAngular(() => {
            onStable$.pipe(withLatestFrom(this.textarea$), takeUntil(this.destroy$)).subscribe(([, textarea]) => {
                if (textarea) {
                    textarea.nativeElement.focus();
                    textarea.nativeElement.value = this.currentText || '';
                    this.autosizeDirective.resizeToFitContent();
                    this.cdr.markForCheck();
                }
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTextEditComponent, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i1.NzI18nService }, { token: i2.NzDestroyService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.10", type: NzTextEditComponent, selector: "nz-text-edit", inputs: { text: "text", icon: "icon", tooltip: "tooltip" }, outputs: { startEditing: "startEditing", endEditing: "endEditing" }, providers: [NzDestroyService], viewQueries: [{ propertyName: "textarea", first: true, predicate: ["textarea"], descendants: true }, { propertyName: "autosizeDirective", first: true, predicate: NzAutosizeDirective, descendants: true }], exportAs: ["nzTextEdit"], ngImport: i0, template: `
    <ng-template [ngIf]="editing" [ngIfElse]="notEditing">
      <textarea #textarea nz-input nzAutosize (blur)="confirm()"></textarea>
      <button nz-trans-button class="ant-typography-edit-content-confirm" (click)="confirm()">
        <span nz-icon nzType="enter"></span>
      </button>
    </ng-template>

    <ng-template #notEditing>
      <button
        nz-tooltip
        nz-trans-button
        class="ant-typography-edit"
        [nzTooltipTitle]="tooltip === null ? null : tooltip || locale?.edit"
        (click)="onClick()"
      >
        <ng-container *nzStringTemplateOutlet="icon; let icon">
          <span nz-icon [nzType]="icon"></span>
        </ng-container>
      </button>
    </ng-template>
  `, isInline: true, dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NzIconDirective, selector: "[nz-icon]", inputs: ["nzSpin", "nzRotate", "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], exportAs: ["nzIcon"] }, { kind: "directive", type: i5.NzTooltipDirective, selector: "[nz-tooltip]", inputs: ["nzTooltipTitle", "nzTooltipTitleContext", "nz-tooltip", "nzTooltipTrigger", "nzTooltipPlacement", "nzTooltipOrigin", "nzTooltipVisible", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipArrowPointAtCenter", "nzTooltipColor"], outputs: ["nzTooltipVisibleChange"], exportAs: ["nzTooltip"] }, { kind: "directive", type: i6.NzInputDirective, selector: "input[nz-input],textarea[nz-input]", inputs: ["nzBorderless", "nzSize", "nzStepperless", "nzStatus", "disabled"], exportAs: ["nzInput"] }, { kind: "directive", type: i6.NzAutosizeDirective, selector: "textarea[nzAutosize]", inputs: ["nzAutosize"], exportAs: ["nzAutosize"] }, { kind: "directive", type: i7.NzTransButtonDirective, selector: "button[nz-trans-button]" }, { kind: "directive", type: i8.NzStringTemplateOutletDirective, selector: "[nzStringTemplateOutlet]", inputs: ["nzStringTemplateOutletContext", "nzStringTemplateOutlet"], exportAs: ["nzStringTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
export { NzTextEditComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.10", ngImport: i0, type: NzTextEditComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-text-edit',
                    exportAs: 'nzTextEdit',
                    template: `
    <ng-template [ngIf]="editing" [ngIfElse]="notEditing">
      <textarea #textarea nz-input nzAutosize (blur)="confirm()"></textarea>
      <button nz-trans-button class="ant-typography-edit-content-confirm" (click)="confirm()">
        <span nz-icon nzType="enter"></span>
      </button>
    </ng-template>

    <ng-template #notEditing>
      <button
        nz-tooltip
        nz-trans-button
        class="ant-typography-edit"
        [nzTooltipTitle]="tooltip === null ? null : tooltip || locale?.edit"
        (click)="onClick()"
      >
        <ng-container *nzStringTemplateOutlet="icon; let icon">
          <span nz-icon [nzType]="icon"></span>
        </ng-container>
      </button>
    </ng-template>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    preserveWhitespaces: false,
                    providers: [NzDestroyService]
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.NzI18nService }, { type: i2.NzDestroyService }]; }, propDecorators: { text: [{
                type: Input
            }], icon: [{
                type: Input
            }], tooltip: [{
                type: Input
            }], startEditing: [{
                type: Output
            }], endEditing: [{
                type: Output
            }], textarea: [{
                type: ViewChild,
                args: ['textarea', { static: false }]
            }], autosizeDirective: [{
                type: ViewChild,
                args: [NzAutosizeDirective, { static: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC1lZGl0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2NvbXBvbmVudHMvdHlwb2dyYXBoeS90ZXh0LWVkaXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdEQsT0FBTyxFQUNMLHVCQUF1QixFQUV2QixTQUFTLEVBRVQsWUFBWSxFQUNaLEtBQUssRUFHTCxNQUFNLEVBQ04sU0FBUyxFQUNULGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsZUFBZSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMzRSxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsY0FBYyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFNUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFHL0QsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUJBQXFCLENBQUM7Ozs7Ozs7Ozs7QUFFMUQsTUE4QmEsbUJBQW1CO0lBUzlCLElBQ0ksUUFBUSxDQUFDLFFBQXFEO1FBQ2hFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFZRCxZQUNVLE1BQWMsRUFDZCxJQUE2QixFQUM3QixHQUFzQixFQUN0QixJQUFtQixFQUNuQixRQUEwQjtRQUoxQixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsU0FBSSxHQUFKLElBQUksQ0FBeUI7UUFDN0IsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFDdEIsU0FBSSxHQUFKLElBQUksQ0FBZTtRQUNuQixhQUFRLEdBQVIsUUFBUSxDQUFrQjtRQTVCcEMsWUFBTyxHQUFHLEtBQUss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Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgRU5URVIsIEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgVmlld0NoaWxkLFxuICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgRU1QVFksIGZyb20sIGZyb21FdmVudCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCB0YWtlLCB0YWtlVW50aWwsIHdpdGhMYXRlc3RGcm9tIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOekRlc3Ryb3lTZXJ2aWNlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3NlcnZpY2VzJztcbmltcG9ydCB7IE56VFNUeXBlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3R5cGVzJztcbmltcG9ydCB7IE56STE4blNlcnZpY2UsIE56VGV4dEkxOG5JbnRlcmZhY2UgfSBmcm9tICduZy16b3Jyby1hbnRkL2kxOG4nO1xuaW1wb3J0IHsgTnpBdXRvc2l6ZURpcmVjdGl2ZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvaW5wdXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduei10ZXh0LWVkaXQnLFxuICBleHBvcnRBczogJ256VGV4dEVkaXQnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJlZGl0aW5nXCIgW25nSWZFbHNlXT1cIm5vdEVkaXRpbmdcIj5cbiAgICAgIDx0ZXh0YXJlYSAjdGV4dGFyZWEgbnotaW5wdXQgbnpBdXRvc2l6ZSAoYmx1cik9XCJjb25maXJtKClcIj48L3RleHRhcmVhPlxuICAgICAgPGJ1dHRvbiBuei10cmFucy1idXR0b24gY2xhc3M9XCJhbnQtdHlwb2dyYXBoeS1lZGl0LWNvbnRlbnQtY29uZmlybVwiIChjbGljayk9XCJjb25maXJtKClcIj5cbiAgICAgICAgPHNwYW4gbnotaWNvbiBuelR5cGU9XCJlbnRlclwiPjwvc3Bhbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgI25vdEVkaXRpbmc+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIG56LXRvb2x0aXBcbiAgICAgICAgbnotdHJhbnMtYnV0dG9uXG4gICAgICAgIGNsYXNzPVwiYW50LXR5cG9ncmFwaHktZWRpdFwiXG4gICAgICAgIFtuelRvb2x0aXBUaXRsZV09XCJ0b29sdGlwID09PSBudWxsID8gbnVsbCA6IHRvb2x0aXAgfHwgbG9jYWxlPy5lZGl0XCJcbiAgICAgICAgKGNsaWNrKT1cIm9uQ2xpY2soKVwiXG4gICAgICA+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm56U3RyaW5nVGVtcGxhdGVPdXRsZXQ9XCJpY29uOyBsZXQgaWNvblwiPlxuICAgICAgICAgIDxzcGFuIG56LWljb24gW256VHlwZV09XCJpY29uXCI+PC9zcGFuPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvbmctdGVtcGxhdGU+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgcHJvdmlkZXJzOiBbTnpEZXN0cm95U2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgTnpUZXh0RWRpdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGVkaXRpbmcgPSBmYWxzZTtcbiAgbG9jYWxlITogTnpUZXh0STE4bkludGVyZmFjZTtcblxuICBASW5wdXQoKSB0ZXh0Pzogc3RyaW5nO1xuICBASW5wdXQoKSBpY29uOiBOelRTVHlwZSA9ICdlZGl0JztcbiAgQElucHV0KCkgdG9vbHRpcD86IG51bGwgfCBOelRTVHlwZTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IHN0YXJ0RWRpdGluZyA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IGVuZEVkaXRpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4odHJ1ZSk7XG4gIEBWaWV3Q2hpbGQoJ3RleHRhcmVhJywgeyBzdGF0aWM6IGZhbHNlIH0pXG4gIHNldCB0ZXh0YXJlYSh0ZXh0YXJlYTogRWxlbWVudFJlZjxIVE1MVGV4dEFyZWFFbGVtZW50PiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudGV4dGFyZWEkLm5leHQodGV4dGFyZWEpO1xuICB9XG4gIEBWaWV3Q2hpbGQoTnpBdXRvc2l6ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pIGF1dG9zaXplRGlyZWN0aXZlITogTnpBdXRvc2l6ZURpcmVjdGl2ZTtcblxuICBiZWZvcmVUZXh0Pzogc3RyaW5nO1xuICBjdXJyZW50VGV4dD86IHN0cmluZztcbiAgbmF0aXZlRWxlbWVudCA9IHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50O1xuXG4gIC8vIFdlIGNvdWxkJ3ZlIHNhdmVkIHRoZSB0ZXh0YXJlYSB3aXRoaW4gc29tZSBwcml2YXRlIHByb3BlcnR5IChlLmcuIGBfdGV4dGFyZWFgKSBhbmQgaGF2ZSBhIGdldHRlcixcbiAgLy8gYnV0IGhhdmluZyBzdWJqZWN0IG1ha2VzIHRoZSBjb2RlIG1vcmUgcmVhY3RpdmUgYW5kIGNhbmNlbGxhYmxlIChlLmcuIGV2ZW50IGxpc3RlbmVycyB3aWxsIGJlXG4gIC8vIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhbmQgcmUtYWRkZWQgdGhyb3VnaCB0aGUgYHN3aXRjaE1hcGAgYmVsb3cpLlxuICBwcml2YXRlIHRleHRhcmVhJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RWxlbWVudFJlZjxIVE1MVGV4dEFyZWFFbGVtZW50PiB8IG51bGwgfCB1bmRlZmluZWQ+KG51bGwpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUsXG4gICAgcHJpdmF0ZSBob3N0OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBpMThuOiBOekkxOG5TZXJ2aWNlLFxuICAgIHByaXZhdGUgZGVzdHJveSQ6IE56RGVzdHJveVNlcnZpY2VcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuaTE4bi5sb2NhbGVDaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmxvY2FsZSA9IHRoaXMuaTE4bi5nZXRMb2NhbGVEYXRhKCdUZXh0Jyk7XG4gICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9KTtcblxuICAgIHRoaXMudGV4dGFyZWEkXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKHRleHRhcmVhID0+XG4gICAgICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGV4cGxpY2l0bHkgc2hvdWxkIGNhbGwgYHN1YnNjcmliZSgpYCB3aXRoaW4gdGhlIHJvb3Qgem9uZS5cbiAgICAgICAgICAvLyBgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gZnJvbUV2ZW50KC4uLikpYCB3aWxsIGp1c3QgY3JlYXRlIGFuIG9ic2VydmFibGUgd2l0aGluIHRoZSByb290IHpvbmUsXG4gICAgICAgICAgLy8gYnV0IGBhZGRFdmVudExpc3RlbmVyYCBpcyBjYWxsZWQgd2hlbiB0aGUgYGZyb21FdmVudGAgaXMgc3Vic2NyaWJlZC5cbiAgICAgICAgICB0ZXh0YXJlYVxuICAgICAgICAgICAgPyBuZXcgT2JzZXJ2YWJsZTxLZXlib2FyZEV2ZW50PihzdWJzY3JpYmVyID0+XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgICAgICAgICAgIGZyb21FdmVudDxLZXlib2FyZEV2ZW50Pih0ZXh0YXJlYS5uYXRpdmVFbGVtZW50LCAna2V5ZG93bicpLnN1YnNjcmliZShzdWJzY3JpYmVyKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBFTVBUWVxuICAgICAgICApLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICAvLyBDYXJldGFrZXIgbm90ZTogYWRkaW5nIG1vZGlmaWVyIGF0IHRoZSBlbmQgKGZvciBpbnN0YW5jZSBgKGtleWRvd24uZXNjKWApIHdpbGwgdGVsbCBBbmd1bGFyIHRvIGFkZFxuICAgICAgICAvLyBhbiBldmVudCBsaXN0ZW5lciB0aHJvdWdoIHRoZSBgS2V5RXZlbnRzUGx1Z2luYCwgd2hpY2ggYWx3YXlzIHJ1bnMgYG5nWm9uZS5ydW5HdWFyZGVkKClgIGludGVybmFsbHkuXG4gICAgICAgIC8vIFdlJ3JlIGludGVyZXN0ZWQgb25seSBpbiBlc2NhcGUgYW5kIGVudGVyIGtleWJvYXJkIGJ1dHRvbnMsIG90aGVyd2lzZSBBbmd1bGFyIHdpbGwgcnVuIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgICAgLy8gb24gYW55IGBrZXlkb3duYCBldmVudC5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT09IEVTQ0FQRSAmJiBldmVudC5rZXlDb2RlICE9PSBFTlRFUikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSkge1xuICAgICAgICAgICAgdGhpcy5vbkNhbmNlbCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRW50ZXIoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIHRoaXMudGV4dGFyZWEkXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKHRleHRhcmVhID0+XG4gICAgICAgICAgdGV4dGFyZWFcbiAgICAgICAgICAgID8gbmV3IE9ic2VydmFibGU8S2V5Ym9hcmRFdmVudD4oc3Vic2NyaWJlciA9PlxuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICAgICAgICBmcm9tRXZlbnQ8S2V5Ym9hcmRFdmVudD4odGV4dGFyZWEubmF0aXZlRWxlbWVudCwgJ2lucHV0Jykuc3Vic2NyaWJlKHN1YnNjcmliZXIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IEVNUFRZXG4gICAgICAgICksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudFRleHQgPSAoZXZlbnQudGFyZ2V0IGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQpLnZhbHVlO1xuICAgICAgfSk7XG4gIH1cblxuICBvbkNsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMuYmVmb3JlVGV4dCA9IHRoaXMudGV4dDtcbiAgICB0aGlzLmN1cnJlbnRUZXh0ID0gdGhpcy5iZWZvcmVUZXh0O1xuICAgIHRoaXMuZWRpdGluZyA9IHRydWU7XG4gICAgdGhpcy5zdGFydEVkaXRpbmcuZW1pdCgpO1xuICAgIHRoaXMuZm9jdXNBbmRTZXRWYWx1ZSgpO1xuICB9XG5cbiAgY29uZmlybSgpOiB2b2lkIHtcbiAgICB0aGlzLmVkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuZEVkaXRpbmcuZW1pdCh0aGlzLmN1cnJlbnRUZXh0KTtcbiAgfVxuXG4gIG9uRW50ZXIoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmNvbmZpcm0oKTtcbiAgfVxuXG4gIG9uQ2FuY2VsKCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRleHQgPSB0aGlzLmJlZm9yZVRleHQ7XG4gICAgdGhpcy5jb25maXJtKCk7XG4gIH1cblxuICBmb2N1c0FuZFNldFZhbHVlKCk6IHZvaWQge1xuICAgIC8vIE5vdGU6IHRoZSB6b25lIG1heSBiZSBub29wZWQgdGhyb3VnaCBgQm9vdHN0cmFwT3B0aW9uc2Agd2hlbiBib290c3RyYXBwaW5nIHRoZSByb290IG1vZHVsZS4gVGhpcyBtZWFuc1xuICAgIC8vIHRoZSBgb25TdGFibGVgIHdpbGwgbmV2ZXIgZW1pdCBhbnkgdmFsdWUuXG4gICAgY29uc3Qgb25TdGFibGUkID0gdGhpcy5uZ1pvbmUuaXNTdGFibGUgPyBmcm9tKFByb21pc2UucmVzb2x2ZSgpKSA6IHRoaXMubmdab25lLm9uU3RhYmxlLnBpcGUodGFrZSgxKSk7XG4gICAgLy8gTm9ybWFsbHkgdGhpcyBpc24ndCBpbiB0aGUgem9uZSwgYnV0IGl0IGNhbiBjYXVzZSBwZXJmb3JtYW5jZSByZWdyZXNzaW9ucyBmb3IgYXBwc1xuICAgIC8vIHVzaW5nIGB6b25lLXBhdGNoLXJ4anNgIGJlY2F1c2UgaXQnbGwgdHJpZ2dlciBhIGNoYW5nZSBkZXRlY3Rpb24gd2hlbiBpdCB1bnN1YnNjcmliZXMuXG4gICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgb25TdGFibGUkLnBpcGUod2l0aExhdGVzdEZyb20odGhpcy50ZXh0YXJlYSQpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoWywgdGV4dGFyZWFdKSA9PiB7XG4gICAgICAgIGlmICh0ZXh0YXJlYSkge1xuICAgICAgICAgIHRleHRhcmVhLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB0ZXh0YXJlYS5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5jdXJyZW50VGV4dCB8fCAnJztcbiAgICAgICAgICB0aGlzLmF1dG9zaXplRGlyZWN0aXZlLnJlc2l6ZVRvRml0Q29udGVudCgpO1xuICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIl19